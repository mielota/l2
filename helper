#! /bin/sh

# Ces variables peuvent être override par l'utilisateur
quiet=${quiet:-0}
format=${format:-"pdf"}
typst_src_dir=${typst_src_dir:-"drafts"}
typst_output_dir=${typst_output_dir:-"content"}

blue="\033[34m"
bold_blue="\033[1;34m"
green="\033[32m"
bold_green="\033[1;32m"
yellow="\033[33m"
red="\033[31m"
no_color="\033[0m"

colored_output() {
	color_name=$1
	shift
	case $color_name in
		blue)
			color=$blue;;
		bold_blue)
			color=$bold_blue;;
		green)
			color=$green;;
		bold_green)
			color=$bold_green;;
		yellow)
			color=$yellow;;
		red)
			color=$red;;
		*)
			color=$no_color;;
	esac

	printf "${color}$@${no_color}\n"
}

helper_log() {

	if [ $quiet -gt 0 ]; then
		exit 0
	fi

	log_request=$1
	shift
	case $log_request in
		info)
			log_level=$(colored_output blue INFO);;
		success)
			log_level=$(colored_output green SUCCESS);;
		warn)
			log_level=$(colored_output yellow WARNING);;
		testing)
			log_level=$(colored_output yellow TEST);;
		err)
			log_level=$(colored_output red ERROR);;
		fail)
			log_level=$(colored_output red FAILED);;
		*)
			log_level=?
	esac

	if [ $log_level != "FAILED" ] && [ $log_level != "ERROR" ]; then
		printf "[$log_level] $@\n"
	else
		printf "[$log_level] $@\n >&2"
	fi
}

display_help() {
 echo -e "
$(colored_output bold_green "Utilisation:")

	$(colored_output bold_blue "helper") COMMANDE

	ou

	$(colored_output bold_blue "helper")
	> COMMANDE
	> COMMANDE
	> quit


$(colored_output bold_green "Commandes:")

	$(colored_output bold_blue "help")
		Affiche ce message.

	$(colored_output bold_blue "quit")
		Quitte helper.

	$(colored_output bold_blue "check")
		Vérifie que toutes les dépendances de helper sont installées.

	$(colored_output bold_blue "sync")
		Met à jour le contenu de 'l2', alternativement, utilisez 'git pull'

	$(colored_output bold_blue "build")
		Compile les fichiers typst en pdf.
		Autres formats possibles voir 'Variables Utilisateur'.

	$(colored_output bold_blue "clean")
		Supprime tout les fichiers typst compilés.


$(colored_output bold_green "Variables utilisateurs:")

	$(colored_output bold_blue "quiet")
		Désactivez la sortie standard et erreur du programme avec :
		quiet=1 ./helper COMMANDE
		valeur par défaut : 0

	$(colored_output bold_blue "format")
		Vous pouvez modifier le format ciblé par une commande de helper.
		Exemple : format=png ./helper build va compiler les fichiers en png.
		Valeurs possibles : pdf, png, svg
		valeur par défaut : pdf

	$(colored_output bold_blue "typst_src_dir")
		Dossier contenant le code typst à compiler.
		valeur par défaut : drafts

	$(colored_output bold_blue "typst_output_dir")
		Dossier qui va contenir le/les futur(s) fichiers typst compilés.
		valeur par défaut : content
"
}

greet_user() {
	hour=$(date +%H)

	if [ "$hour" -ge 6 ] && [ "$hour" -lt 18 ]; then
		greet="Bonjour"
	else
		greet="Bonsoir"
	fi

	helper_log info "$greet $(whoami)"
}

unknown_cmd() {
	echo "Je comprends pas ta requête. Renseignes toi avec './helper help'"
}

eval_input() {
	case $1 in
		help)display_help;;
		quit)echo "bye $(whoami) ♥" ; exit 0;;
		check)check;;
		sync)sync;;
		build)build;;
		clean)clean;;
		*)unknown_cmd;;
	esac
}

check() {
	helper_log testing "Vérifications des dépendances."
	git -v > /dev/null 2>&1 || (helper_log fail "La dépendance git n'est pas installé !" && exit 1)
	typst --version > /dev/null 2>&1 || (helper_log fail "La dépendance typst n'est pas installé !" && exit 1)
	helper_log success "Toutes les dépendances sont satisfaites."
}

sync() {
	helper_log info "Mise à jour du dépôt via git"
	git pull
}

build() {
	typ_files="$(find $typst_src_dir -name "*.typ")"

	compiled=0

	for file in $typ_files; do
		target_path=$(echo $file | sed "s/drafts/"$typst_output_dir"/g; s/\.typ$/."$format"/g")
		target_dir=$(dirname $target_path)

		if ! [ -d $target_dir ]; then
			mkdir -p $target_dir
		fi

		if [ -f $target_path ]; then
			helper_log warn "Le fichier $file est déjà compilé sur $target_path, annulation."
		else
			helper_log info "Compilation de $file dans $target_path"
			typst compile $file $target_path
			if [ -f $target_path ]; then
				helper_log success "Compilation de $file dans $target_path réussie."
				compiled=$(expr $compiled + 1)
			else
				helper_log fail "La compilation de $file dans $target_path a échouée."
			fi
		fi
	done

	helper_log info "Trouvés : $(echo "$typ_files" | wc -l) fichiers typst."
	helper_log info "Compilés : $compiled fichiers $format."
}

clean() {
	build_files="$(find $typst_output_dir -name "*.$format")"

	deleted=0

	for file in $build_files; do
		helper_log info "Suppression de $file"
		rm $file
		if ! [ -f $file ]; then
			helper_log success "Suppression de $file réussie."
			deleted=$(expr $deleted + 1)
		else
			helper_log fail "La suppression de $file a échouée."
		fi
	done

	helper_log info "Trouvés : $(echo "$build_files" | wc -l) fichiers typst."
	helper_log info "Supprimés: $deleted fichiers $format."
}

if ! [ -d $typst_src_dir ]; then
	mkdir $typst_src_dir
fi

if ! [ -d $typst_output_dir ]; then
	mkdir $typst_output_dir
fi

empty_dirs="$(find content/ -type d -empty -not -path "content/")"

if [ -n "$empty_dirs" ]; then
	helper_log warn "$(echo "$empty_dirs" | wc -l) dossier(s) vide(s) a/ont été trouvé(s)."
	helper_log info "Suppression de ce(s) dossier(s)."

	for dir in $empty_dirs; do
		helper_log info "Suppression de $dir"
		rmdir $dir && helper_log success "Suppression de $dir réussie." || helper_log fail "$dir n'a pas pu être supprimé."
	done
fi

if [ $# -eq 0 ]; then
	greet_user
	while true; do
		echo -n "> "
		read user_input
		eval_input $user_input
	done
elif [ $# -eq 1 ]; then
	eval_input $1
else
	unknown_cmd
fi
